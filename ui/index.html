<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azul Solver & Analysis Toolkit</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .tile {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid #374151;
            user-select: none;
        }
        .tile:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .tile.dragging {
            opacity: 0.5;
            transform: scale(1.2);
            z-index: 1000;
        }
        .tile.drag-over {
            background-color: rgba(59, 130, 246, 0.3) !important;
            border-color: #3b82f6 !important;
        }
        .factory {
            border: 2px solid #374151;
            border-radius: 8px;
            padding: 8px;
            margin: 4px;
            background: #f9fafb;
        }
        .pattern-line {
            display: flex;
            gap: 2px;
            margin: 2px 0;
            min-height: 40px;
            border: 2px dashed transparent;
            border-radius: 4px;
            padding: 2px;
        }
        .pattern-line.drag-over {
            border-color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
        }
        .wall {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin: 4px 0;
        }
        .wall-cell {
            width: 30px;
            height: 30px;
            border: 1px solid #d1d5db;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .wall-cell.drag-over {
            background-color: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }
        .heatmap-green { background-color: rgba(34, 197, 94, 0.3); }
        .heatmap-yellow { background-color: rgba(234, 179, 8, 0.3); }
        .heatmap-red { background-color: rgba(239, 68, 68, 0.3); }
        .move-option {
            padding: 8px;
            margin: 4px 0;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .move-option:hover {
            background-color: #f3f4f6;
        }
        .move-option.selected {
            background-color: #3b82f6;
            color: white;
        }
        .status-success { color: #059669; }
        .status-error { color: #dc2626; }
        .status-warning { color: #d97706; }
        
        /* Drag and drop visual feedback */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            opacity: 0.8;
            transform: rotate(5deg);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // API Configuration - Use relative URLs to avoid CORS issues
        const API_BASE = '/api/v1';
        let sessionId = null;

        // Sandbox state management
        let moveHistory = [];
        let undoStack = [];
        let currentGameState = null;
        let draggedTile = null;
        let dragGhost = null;

        // Initialize session
        async function initializeSession() {
            try {
                const response = await fetch(`${API_BASE}/auth/session`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_agent: navigator.userAgent,
                        ip_address: '127.0.0.1'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    sessionId = data.session_id;
                    console.log('Session initialized:', sessionId);
                    return true;
                } else {
                    console.error('Session creation failed:', response.status);
                    return false;
                }
            } catch (error) {
                console.error('Failed to initialize session:', error);
                return false;
            }
        }

        // API helper functions
        async function analyzePosition(fenString) {
            if (!sessionId) {
                console.error('No session ID available');
                return null;
            }
            
            try {
                const response = await fetch(`${API_BASE}/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': sessionId
                    },
                    body: JSON.stringify({
                        fen_string: fenString,
                        depth: 3,
                        time_budget: 4.0,
                        agent_id: 0
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.success ? data.analysis : null;
                } else {
                    console.error('Analysis failed:', response.status, response.statusText);
                    return null;
                }
            } catch (error) {
                console.error('Analysis error:', error);
                return null;
            }
        }

        async function getGameState(fenString = 'initial') {
            
            try {
                const response = await fetch(`${API_BASE}/game_state?fen_string=${fenString}`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.success ? data.game_state : null;
                } else {
                    console.error('Game state fetch failed:', response.status, response.statusText);
                    return null;
                }
            } catch (error) {
                console.error('Game state error:', error);
                return null;
            }
        }

        async function getHint(fenString) {
            if (!sessionId) {
                console.error('No session ID available');
                return null;
            }
            
            try {
                const response = await fetch(`${API_BASE}/hint`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': sessionId
                    },
                    body: JSON.stringify({
                        fen_string: fenString,
                        budget: 0.2,
                        rollouts: 100,
                        agent_id: 0
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.success ? data.hint : null;
                } else {
                    console.error('Hint failed:', response.status, response.statusText);
                    return null;
                }
            } catch (error) {
                console.error('Hint error:', error);
                return null;
            }
        }

        async function analyzeNeural(fenString) {
            if (!sessionId) {
                console.error('No session ID available');
                return null;
            }
            
            try {
                const response = await fetch(`${API_BASE}/analyze_neural`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': sessionId
                    },
                    body: JSON.stringify({
                        fen_string: fenString,
                        time_budget: 1.0,
                        max_rollouts: 50,
                        agent_id: 0
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.success ? data.analysis : null;
                } else {
                    console.error('Neural analysis failed:', response.status, response.statusText);
                    return null;
                }
            } catch (error) {
                console.error('Neural analysis error:', error);
                return null;
            }
        }

        // Tile colors mapping
        const TILE_COLORS = {
            'R': '#ef4444', // red
            'B': '#3b82f6', // blue
            'Y': '#eab308', // yellow
            'W': '#f3f4f6', // white
            'K': '#1f2937', // black
        };

        // Sample game state (simplified FEN-like format)
        const SAMPLE_STATE = {
            factories: [
                ['K', 'R', 'B', 'Y', 'W', 'W'], // Factory 1: 1 black, 1 red, 1 blue, 1 yellow, 2 empty
                ['R', 'B', 'Y', 'W', 'K', 'K'], // Factory 2: 1 red, 1 blue, 1 yellow, 1 white, 2 black
                ['Y', 'B', 'W', 'K', 'R', 'W'], // Factory 3: 1 yellow, 1 blue, 1 empty, 1 black, 1 red, 1 empty
                ['Y', 'W', 'R', 'B', 'W', 'W'], // Factory 4: 1 yellow, 1 empty, 1 red, 1 blue, 2 empty
            ],
            center: ['R', 'B', 'Y'],
            players: [
                {
                    pattern_lines: [
                        ['R', 'B'],
                        ['Y'],
                        [],
                        [],
                        []
                    ],
                    wall: [
                        [false, false, false, false, false],
                        [false, false, false, false, false],
                        [false, false, false, false, false],
                        [false, false, false, false, false],
                        [false, false, false, false, false]
                    ],
                    floor: ['R', 'B']
                }
            ]
        };

        // Tile Component with proper drag-and-drop
        function Tile({ color, onClick, className = "", draggable = false, onDragStart, onDragEnd, dataAttributes = {} }) {
            const tileRef = React.useRef(null);
            
            useEffect(() => {
                const tile = tileRef.current;
                if (!tile || !draggable) return;
                
                const handleDragStart = (e) => {
                    if (onDragStart) {
                        onDragStart(e, tile);
                    }
                };
                
                const handleDragEnd = (e) => {
                    if (onDragEnd) {
                        onDragEnd(e, tile);
                    }
                };
                
                tile.addEventListener('dragstart', handleDragStart);
                tile.addEventListener('dragend', handleDragEnd);
                
                return () => {
                    tile.removeEventListener('dragstart', handleDragStart);
                    tile.removeEventListener('dragend', handleDragEnd);
                };
            }, [draggable, onDragStart, onDragEnd]);
            
            return (
                <div 
                    ref={tileRef}
                    className={`tile ${className}`}
                    style={{ backgroundColor: TILE_COLORS[color] || '#6b7280' }}
                    onClick={onClick}
                    title={color}
                    draggable={draggable}
                    {...dataAttributes}
                />
            );
        }

        // Factory Component with drag-and-drop
        function Factory({ tiles, onTileClick, heatmap = null, factoryIndex }) {
            const factoryRef = React.useRef(null);
            
            useEffect(() => {
                const factory = factoryRef.current;
                if (!factory) return;
                
                const handleDragOver = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.add('drag-over');
                };
                
                const handleDragLeave = (e) => {
                    e.currentTarget.classList.remove('drag-over');
                };
                
                const handleDrop = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const tileData = e.dataTransfer.getData('application/json');
                    if (tileData) {
                        const data = JSON.parse(tileData);
                        // Handle drop on factory (not implemented yet)
                        console.log('Drop on factory:', data);
                    }
                };
                
                factory.addEventListener('dragover', handleDragOver);
                factory.addEventListener('dragleave', handleDragLeave);
                factory.addEventListener('drop', handleDrop);
                
                return () => {
                    factory.removeEventListener('dragover', handleDragOver);
                    factory.removeEventListener('dragleave', handleDragLeave);
                    factory.removeEventListener('drop', handleDrop);
                };
            }, []);
            
            return (
                <div ref={factoryRef} className="factory">
                    <div className="text-xs text-gray-600 mb-2">Factory {factoryIndex + 1}</div>
                    <div className="flex flex-wrap gap-1">
                        {tiles.map((tile, index) => (
                            <Tile 
                                key={index}
                                color={tile}
                                onClick={() => onTileClick(tile, index)}
                                className={heatmap ? `heatmap-${heatmap}` : ""}
                                draggable={tile !== 'W'} // Only non-empty tiles are draggable
                                onDragStart={(e, tileElement) => {
                                    console.log('Factory tile drag start:', tile, factoryIndex, index);
                                    
                                    const tileData = {
                                        tile: tile,
                                        factoryIndex: factoryIndex,
                                        tileIndex: index,
                                        sourceId: factoryIndex
                                    };
                                    console.log('Setting drag data:', tileData);
                                    
                                    e.dataTransfer.setData('application/json', JSON.stringify(tileData));
                                    e.dataTransfer.effectAllowed = 'move';
                                    tileElement.classList.add('dragging');
                                    
                                    // Create drag ghost
                                    dragGhost = tileElement.cloneNode(true);
                                    dragGhost.classList.add('drag-ghost');
                                    dragGhost.style.width = '40px';
                                    dragGhost.style.height = '40px';
                                    document.body.appendChild(dragGhost);
                                    e.dataTransfer.setDragImage(dragGhost, 20, 20);
                                }}
                                onDragEnd={(e, tileElement) => {
                                    tileElement.classList.remove('dragging');
                                    if (dragGhost) {
                                        document.body.removeChild(dragGhost);
                                        dragGhost = null;
                                    }
                                }}
                            />
                        ))}
                    </div>
                </div>
            );
        }

        // Pattern Line Component with drop zones
        function PatternLine({ tiles, rowIndex, maxTiles, onTileClick, onDrop }) {
            const patternLineRef = React.useRef(null);
            
            useEffect(() => {
                const patternLine = patternLineRef.current;
                if (!patternLine) return;
                
                const handleDragOver = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.add('drag-over');
                };
                
                const handleDragLeave = (e) => {
                    e.currentTarget.classList.remove('drag-over');
                };
                
                const handleDrop = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    console.log('PatternLine drop event triggered');
                    
                    const tileData = e.dataTransfer.getData('application/json');
                    console.log('Tile data from drop:', tileData);
                    
                    if (tileData) {
                        const data = JSON.parse(tileData);
                        console.log('Parsed data:', data);
                        if (onDrop) {
                            console.log('Calling onDrop with:', data, rowIndex);
                            onDrop(data, rowIndex);
                        } else {
                            console.log('onDrop is not defined');
                        }
                    } else {
                        console.log('No tile data found in drop event');
                    }
                };
                
                patternLine.addEventListener('dragover', handleDragOver);
                patternLine.addEventListener('dragleave', handleDragLeave);
                patternLine.addEventListener('drop', handleDrop);
                
                return () => {
                    patternLine.removeEventListener('dragover', handleDragOver);
                    patternLine.removeEventListener('dragleave', handleDragLeave);
                    patternLine.removeEventListener('drop', handleDrop);
                };
            }, [onDrop, rowIndex, patternLineRef]);
            
            const emptySlots = Math.max(0, maxTiles - tiles.length);
            return (
                <div ref={patternLineRef} className="pattern-line">
                    {tiles.map((tile, index) => (
                        <Tile 
                            key={index}
                            color={tile}
                            onClick={() => onTileClick(rowIndex, index)}
                        />
                    ))}
                    {Array.from({ length: emptySlots }, (_, index) => (
                        <div 
                            key={`empty-${index}`}
                            className="tile"
                            style={{ backgroundColor: 'transparent', border: '2px dashed #d1d5db' }}
                            onClick={() => onTileClick(rowIndex, tiles.length + index)}
                        />
                    ))}
                </div>
            );
        }

        // Wall Component with drop zones
        function Wall({ wall, onWallClick, onDrop }) {
            const wallRef = React.useRef(null);
            
            useEffect(() => {
                const wall = wallRef.current;
                if (!wall) return;
                
                const handleDragOver = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.add('drag-over');
                };
                
                const handleDragLeave = (e) => {
                    e.currentTarget.classList.remove('drag-over');
                };
                
                const handleDrop = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const tileData = e.dataTransfer.getData('application/json');
                    if (tileData) {
                        const data = JSON.parse(tileData);
                        const rowIndex = parseInt(e.currentTarget.dataset.row);
                        const colIndex = parseInt(e.currentTarget.dataset.col);
                        if (onDrop) {
                            onDrop(data, rowIndex, colIndex);
                        }
                    }
                };
                
                const cells = wall.querySelectorAll('.wall-cell');
                cells.forEach(cell => {
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('drop', handleDrop);
                });
                
                return () => {
                    cells.forEach(cell => {
                        cell.removeEventListener('dragover', handleDragOver);
                        cell.removeEventListener('dragleave', handleDragLeave);
                        cell.removeEventListener('drop', handleDrop);
                    });
                };
            }, [onDrop]);
            
            return (
                <div ref={wallRef} className="wall">
                    {wall.map((row, rowIndex) => (
                        row.map((cell, colIndex) => (
                            <div 
                                key={`${rowIndex}-${colIndex}`}
                                className={`wall-cell ${cell ? 'occupied' : ''}`}
                                onClick={() => onWallClick(rowIndex, colIndex)}
                                data-row={rowIndex}
                                data-col={colIndex}
                            >
                                {cell && <Tile color={cell} />}
                            </div>
                        ))
                    ))}
                </div>
            );
        }

        // Player Board Component
        function PlayerBoard({ player, playerIndex, onPatternLineClick, onWallClick, onPatternLineDrop, onWallDrop }) {
            return (
                <div className="bg-gray-50 p-4 rounded-lg mb-4">
                    <h4 className="text-lg font-medium mb-3">Player {playerIndex + 1}</h4>
                    
                    {/* Pattern Lines */}
                    <div className="mb-4">
                        <h5 className="text-sm font-medium mb-2">Pattern Lines</h5>
                        {player.pattern_lines.map((line, index) => (
                            <PatternLine 
                                key={index}
                                tiles={line}
                                rowIndex={index}
                                maxTiles={index + 1}
                                onTileClick={onPatternLineClick}
                                onDrop={onPatternLineDrop}
                            />
                        ))}
                    </div>
                    
                    {/* Wall */}
                    <div className="mb-4">
                        <h5 className="text-sm font-medium mb-2">Wall</h5>
                        <Wall 
                            wall={player.wall}
                            onWallClick={onWallClick}
                            onDrop={onWallDrop}
                        />
                    </div>
                    
                    {/* Floor */}
                    <div>
                        <h5 className="text-sm font-medium mb-2">Floor</h5>
                        <div className="flex gap-1">
                            {player.floor.map((tile, index) => (
                                <Tile key={index} color={tile} />
                            ))}
                            {Array.from({ length: Math.max(0, 7 - player.floor.length) }, (_, index) => (
                                <div 
                                    key={`floor-empty-${index}`}
                                    className="tile"
                                    style={{ backgroundColor: 'transparent', border: '2px dashed #d1d5db' }}
                                />
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        // Status Message Component
        function StatusMessage({ type, message }) {
            const typeClasses = {
                success: 'status-success',
                error: 'status-error',
                warning: 'status-warning'
            };
            
            return (
                <div className={`text-center p-3 rounded-lg ${typeClasses[type] || 'text-gray-600'}`}>
                    {message}
                </div>
            );
        }

        // Move Option Component
        function MoveOption({ move, score, visits, onClick, isSelected }) {
            return (
                <div 
                    className={`move-option ${isSelected ? 'selected' : ''}`}
                    onClick={onClick}
                >
                    <div className="flex justify-between items-center">
                        <span className="font-medium">{move}</span>
                        <span className="text-sm">{score?.toFixed(2) || 'N/A'}</span>
                    </div>
                    {visits && <div className="text-xs text-gray-500">Visits: {visits}</div>}
                </div>
            );
        }

        // Main App Component
        function App() {
            const [sessionStatus, setSessionStatus] = useState('connecting');
            const [statusMessage, setStatusMessage] = useState('Initializing...');
            const [loading, setLoading] = useState(false);
            const [gameState, setGameState] = useState(null);
            const [analysis, setAnalysis] = useState(null);
            const [hint, setHint] = useState(null);
            const [selectedMove, setSelectedMove] = useState(null);
            const [fenString, setFenString] = useState('initial');

            // Initialize session and game state on component mount
            useEffect(() => {
                initializeSession().then(success => {
                    if (success) {
                        setSessionStatus('connected');
                        setStatusMessage('‚úÖ Connected to API');
                        
                        // Fetch initial game state
                        getGameState('initial').then(state => {
                            if (state) {
                                setGameState(state);
                                setStatusMessage('‚úÖ Game state loaded');
                            } else {
                                setStatusMessage('‚ùå Failed to load game state');
                            }
                        });
                    } else {
                        setSessionStatus('error');
                        setStatusMessage('‚ùå Failed to connect to API');
                    }
                });
            }, []);

            // Keyboard shortcuts for undo/redo
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z') {
                            e.preventDefault();
                            undoMove();
                        } else if (e.key === 'y') {
                            e.preventDefault();
                            redoMove();
                        }
                    }
                };
                
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, []);

            // Analysis handlers
            const handleAnalyze = async () => {
                setLoading(true);
                setStatusMessage('üîç Analyzing position...');
                
                const result = await analyzePosition(fenString);
                if (result) {
                    setAnalysis(result);
                    setStatusMessage('‚úÖ Analysis complete');
                } else {
                    setStatusMessage('‚ùå Analysis failed');
                }
                
                setLoading(false);
            };

            const handleHint = async () => {
                setLoading(true);
                setStatusMessage('üí° Generating hint...');
                
                const result = await getHint(fenString);
                if (result) {
                    setHint(result);
                    setStatusMessage('‚úÖ Hint generated');
                } else {
                    setStatusMessage('‚ùå Hint generation failed');
                }
                
                setLoading(false);
            };

            const handleNeuralAnalyze = async () => {
                setLoading(true);
                setStatusMessage('üß† Neural analysis...');
                
                const result = await analyzeNeural(fenString);
                if (result) {
                    setAnalysis(result);
                    setStatusMessage('‚úÖ Neural analysis complete');
                } else {
                    setStatusMessage('‚ùå Neural analysis failed');
                }
                
                setLoading(false);
            };

            // Sandbox move execution
            const executeMove = async (moveData) => {
                if (sessionStatus !== 'connected') {
                    setStatusMessage('‚ùå Not connected to API');
                    return;
                }
                
                setLoading(true);
                setStatusMessage('üéØ Executing move...');
                
                const requestData = {
                    fen_string: stateToFen(),
                    move: moveData,
                    agent_id: 0
                };
                
                console.log('Sending request to API:', requestData);
                
                try {
                    const response = await fetch(`${API_BASE}/execute_move`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-ID': sessionId
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    const result = await response.json();
                    console.log('API response:', result);
                    
                    if (result.success) {
                        // Add to move history
                        moveHistory.push({
                            move: moveData,
                            state: stateToFen(),
                            timestamp: Date.now()
                        });
                        
                        // Clear undo stack since we made a new move
                        undoStack = [];
                        
                        // Update game state
                        updateGameState(result.new_fen);
                        
                        setStatusMessage(`‚úÖ Move executed: ${result.move_executed}`);
                        
                        // Show engine response if available
                        if (result.engine_response) {
                            setTimeout(() => {
                                setStatusMessage(`ü§ñ Engine response: ${result.engine_response.move} (${result.engine_response.score.toFixed(2)})`);
                            }, 1000);
                        }
                        
                        // Check if game is over
                        if (result.game_over) {
                            setTimeout(() => {
                                setStatusMessage(`üèÅ Game Over! Final scores: ${result.scores.join(' - ')}`);
                            }, 2000);
                        }
                    } else {
                        setStatusMessage(`‚ùå Move failed: ${result.error}`);
                    }
                } catch (error) {
                    setStatusMessage(`‚ùå Move execution error: ${error.message}`);
                }
                
                setLoading(false);
            };

            // Undo last move
            const undoMove = () => {
                if (moveHistory.length === 0) {
                    setStatusMessage('‚ùå No moves to undo');
                    return;
                }
                
                const lastMove = moveHistory.pop();
                undoStack.push(lastMove);
                
                // Restore previous state
                if (moveHistory.length > 0) {
                    const previousState = moveHistory[moveHistory.length - 1];
                    updateGameState(previousState.state);
                } else {
                    // Back to initial state
                    updateGameState('initial');
                }
                
                setStatusMessage('‚Ü∂ Move undone');
            };

            // Redo move
            const redoMove = () => {
                if (undoStack.length === 0) {
                    setStatusMessage('‚ùå No moves to redo');
                    return;
                }
                
                const moveToRedo = undoStack.pop();
                executeMove(moveToRedo.move);
            };

            // Update game state from FEN
            const updateGameState = (fen) => {
                setFenString(fen);
                
                // Fetch new game state from API
                getGameState(fen).then(state => {
                    if (state) {
                        setGameState(state);
                    }
                });
            };

            // Convert current state to FEN
            const stateToFen = () => {
                return fenString;
            };

            // Convert tile color to type
            const getTileTypeFromColor = (color) => {
                const colorMap = {
                    'B': 0, // blue
                    'Y': 1, // yellow
                    'R': 2, // red
                    'K': 3, // black
                    'W': 4  // white
                };
                return colorMap[color] || 0;
            };

            // Format move description for display
            const formatMoveDescription = (move) => {
                const tileColors = ['red', 'blue', 'yellow', 'black', 'white'];
                const tileColor = tileColors[move.tile_type] || 'unknown';
                const source = move.source_id >= 0 ? `factory ${move.source_id}` : 'center';
                const destination = move.pattern_line_dest >= 0 ? `pattern line ${move.pattern_line_dest}` : 'floor';
                
                return `Take ${tileColor} from ${source} to ${destination}`;
            };

            // Handle pattern line drop
            const handlePatternLineDrop = (tileData, rowIndex) => {
                console.log('handlePatternLineDrop called with:', tileData, rowIndex);
                
                const move = {
                    source_id: tileData.sourceId,
                    tile_type: getTileTypeFromColor(tileData.tile),
                    pattern_line_dest: rowIndex,
                    num_to_pattern_line: 1,
                    num_to_floor_line: 0
                };
                
                console.log('Tile data:', tileData);
                console.log('Generated move:', move);
                
                executeMove(move);
            };

            // Handle wall drop
            const handleWallDrop = (tileData, rowIndex, colIndex) => {
                setStatusMessage('üéØ Wall placement not yet implemented');
            };

            // Handle pattern line click
            const handlePatternLineClick = (rowIndex, tileIndex) => {
                setStatusMessage(`üéØ Pattern line ${rowIndex} clicked`);
            };

            // Handle wall click
            const handleWallClick = (rowIndex, colIndex) => {
                setStatusMessage(`üéØ Wall cell ${rowIndex}, ${colIndex} clicked`);
            };

            return (
                <div className="container mx-auto p-6">
                    <div className="text-center mb-8">
                        <h1 className="text-3xl font-bold text-gray-900 mb-2">
                            Azul Solver & Analysis Toolkit
                        </h1>
                        <p className="text-gray-600 mb-4">
                            Interactive game analysis with live hints and exact evaluation
                        </p>
                        <StatusMessage 
                            type={sessionStatus === 'connected' ? 'success' : sessionStatus === 'error' ? 'error' : 'warning'}
                            message={statusMessage || 'Initializing...'}
                        />
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        {/* Game Board */}
                        <div className="lg:col-span-2">
                            <div className="bg-white p-6 rounded-lg shadow">
                                <h2 className="text-xl font-semibold mb-4">Game Board</h2>
                                
                                {!gameState ? (
                                    <div className="text-center py-8">
                                        <div className="text-gray-500">Loading game state...</div>
                                    </div>
                                ) : (
                                    <>
                                        {/* Factories */}
                                        <div className="mb-6">
                                            <h3 className="text-lg font-medium mb-3">Factories</h3>
                                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                                {gameState.factories.map((factory, index) => (
                                                    <Factory 
                                                        key={index}
                                                        tiles={factory}
                                                        factoryIndex={index}
                                                        onTileClick={(tile, tileIndex) => {
                                                            setStatusMessage(`üéØ Selected ${tile} tile from factory ${index + 1}`);
                                                        }}
                                                    />
                                                ))}
                                            </div>
                                        </div>

                                        {/* Center */}
                                        <div className="mb-6">
                                            <h3 className="text-lg font-medium mb-3">Center</h3>
                                            <div className="flex gap-2">
                                                {gameState.center.map((tile, index) => (
                                                    <Tile 
                                                        key={index}
                                                        color={tile}
                                                        draggable={tile !== 'W'}
                                                        onDragStart={(e, tileElement) => {
                                                            const tileData = {
                                                                tile: tile,
                                                                sourceId: -1, // -1 indicates center pool
                                                                tileIndex: index
                                                            };
                                                            e.dataTransfer.setData('application/json', JSON.stringify(tileData));
                                                            e.dataTransfer.effectAllowed = 'move';
                                                            tileElement.classList.add('dragging');
                                                            
                                                            // Create drag ghost
                                                            dragGhost = tileElement.cloneNode(true);
                                                            dragGhost.classList.add('drag-ghost');
                                                            dragGhost.style.width = '40px';
                                                            dragGhost.style.height = '40px';
                                                            document.body.appendChild(dragGhost);
                                                            e.dataTransfer.setDragImage(dragGhost, 20, 20);
                                                        }}
                                                        onDragEnd={(e, tileElement) => {
                                                            tileElement.classList.remove('dragging');
                                                            if (dragGhost) {
                                                                document.body.removeChild(dragGhost);
                                                                dragGhost = null;
                                                            }
                                                        }}
                                                    />
                                                ))}
                                            </div>
                                        </div>

                                        {/* Player Boards */}
                                        <div>
                                            <h3 className="text-lg font-medium mb-3">Player Boards</h3>
                                            {gameState.players.map((player, index) => (
                                                <PlayerBoard 
                                                    key={index}
                                                    player={player}
                                                    playerIndex={index}
                                                    onPatternLineClick={handlePatternLineClick}
                                                    onWallClick={handleWallClick}
                                                    onPatternLineDrop={handlePatternLineDrop}
                                                    onWallDrop={handleWallDrop}
                                                />
                                            ))}
                                        </div>
                                    </>
                                )}
                            </div>
                        </div>

                        {/* Analysis Panel */}
                        <div className="space-y-6">
                            {/* Controls */}
                            <div className="bg-white p-4 rounded-lg shadow">
                                <h3 className="text-lg font-medium mb-4">Analysis Controls</h3>
                                <div className="space-y-3">
                                    <button 
                                        onClick={handleAnalyze}
                                        disabled={loading || sessionStatus !== 'connected'}
                                        className="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 disabled:opacity-50"
                                    >
                                        {loading ? 'Analyzing...' : 'Exact Analysis (Depth-3)'}
                                    </button>
                                    <button 
                                        onClick={handleHint}
                                        disabled={loading || sessionStatus !== 'connected'}
                                        className="w-full bg-green-600 text-white py-2 px-4 rounded hover:bg-green-700 disabled:opacity-50"
                                    >
                                        {loading ? 'Generating...' : 'Fast Hint (<200ms)'}
                                    </button>
                                    <button 
                                        onClick={handleNeuralAnalyze}
                                        disabled={loading || sessionStatus !== 'connected'}
                                        className="w-full bg-purple-600 text-white py-2 px-4 rounded hover:bg-purple-700 disabled:opacity-50"
                                    >
                                        {loading ? 'Analyzing...' : 'üß† Neural Analysis'}
                                    </button>
                                </div>
                                
                                {/* Sandbox Controls */}
                                <div className="mt-4 pt-4 border-t border-gray-200">
                                    <h4 className="text-md font-medium mb-3">üéÆ Sandbox Controls</h4>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button 
                                            onClick={undoMove}
                                            disabled={loading || moveHistory.length === 0}
                                            className="bg-gray-600 text-white py-2 px-3 rounded hover:bg-gray-700 disabled:opacity-50 text-sm"
                                        >
                                            ‚Ü∂ Undo
                                        </button>
                                        <button 
                                            onClick={redoMove}
                                            disabled={loading || undoStack.length === 0}
                                            className="bg-gray-600 text-white py-2 px-3 rounded hover:bg-gray-700 disabled:opacity-50 text-sm"
                                        >
                                            ‚Ü∑ Redo
                                        </button>
                                    </div>
                                    <div className="mt-2 text-xs text-gray-500">
                                        <p>üí° Drag tiles from factories to pattern lines</p>
                                        <p>‚å®Ô∏è Ctrl+Z: Undo, Ctrl+Y: Redo</p>
                                    </div>
                                </div>
                                
                                <div className="mt-3 text-xs text-gray-500">
                                    <p>‚úÖ Exact Analysis: Alpha-beta search with depth-3</p>
                                    <p>‚úÖ Fast Hint: MCTS with UCT algorithm</p>
                                    <p>üß† Neural Analysis: MCTS with neural rollout policy</p>
                                    <p>‚úÖ Database: SQLite caching enabled</p>
                                </div>
                            </div>

                            {/* FEN Display */}
                            {fenString && (
                                <div className="bg-white p-4 rounded-lg shadow">
                                    <h3 className="text-lg font-medium mb-2">Position FEN</h3>
                                    <textarea 
                                        value={fenString}
                                        readOnly
                                        className="w-full h-20 p-2 text-xs font-mono bg-gray-100 rounded"
                                    />
                                    <p className="text-xs text-gray-500 mt-1">
                                        Note: Currently using "initial" position. Full FEN support coming soon.
                                    </p>
                                </div>
                            )}

                            {/* Analysis Results */}
                            {analysis && (
                                <div className="bg-white p-4 rounded-lg shadow">
                                    <h3 className="text-lg font-medium mb-3">
                                        {analysis.method === 'neural_mcts' ? 'üß† Neural Analysis' : 'Exact Analysis'}
                                    </h3>
                                    <div className="space-y-2 text-sm">
                                        <div><strong>Best Move:</strong> {analysis.best_move || 'None'}</div>
                                        <div><strong>Score:</strong> {analysis.best_score?.toFixed(2) || 'N/A'}</div>
                                        <div><strong>Search Time:</strong> {analysis.search_time?.toFixed(3)}s</div>
                                        {analysis.method === 'neural_mcts' ? (
                                            <>
                                                <div><strong>Rollouts:</strong> {analysis.rollout_count || 'N/A'}</div>
                                                <div><strong>Method:</strong> Neural MCTS</div>
                                            </>
                                        ) : (
                                            <>
                                                <div><strong>Nodes:</strong> {analysis.nodes_searched?.toLocaleString() || 'N/A'}</div>
                                                <div><strong>Depth:</strong> {analysis.depth_reached || 'N/A'}</div>
                                            </>
                                        )}
                                    </div>
                                    
                                    {analysis.principal_variation && analysis.principal_variation.length > 0 && (
                                        <div className="mt-3">
                                            <strong>Principal Variation:</strong>
                                            <div className="text-xs font-mono bg-gray-100 p-2 rounded mt-1">
                                                {analysis.principal_variation.join(' ‚Üí ')}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* Hint Results */}
                            {hint && (
                                <div className="bg-white p-4 rounded-lg shadow">
                                    <h3 className="text-lg font-medium mb-3">Fast Hint</h3>
                                    <div className="space-y-2 text-sm">
                                        <div><strong>Best Move:</strong> {hint.best_move || 'None'}</div>
                                        <div><strong>Expected Value:</strong> {hint.expected_value?.toFixed(2) || 'N/A'}</div>
                                        <div><strong>Confidence:</strong> {hint.confidence?.toFixed(2) || 'N/A'}</div>
                                        <div><strong>Search Time:</strong> {hint.search_time?.toFixed(3)}s</div>
                                        <div><strong>Rollouts:</strong> {hint.rollouts_performed || 'N/A'}</div>
                                    </div>
                                    
                                    {hint.top_moves && hint.top_moves.length > 0 && (
                                        <div className="mt-3">
                                            <strong>Top Moves:</strong>
                                            <div className="space-y-1 mt-2">
                                                {hint.top_moves.slice(0, 3).map((moveData, index) => (
                                                    <MoveOption 
                                                        key={index}
                                                        move={moveData.move}
                                                        score={moveData.score}
                                                        visits={moveData.visits}
                                                        onClick={() => setSelectedMove(moveData.move)}
                                                        isSelected={selectedMove === moveData.move}
                                                    />
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* Move History */}
                            {moveHistory.length > 0 && (
                                <div className="bg-white p-4 rounded-lg shadow">
                                    <h3 className="text-lg font-medium mb-3">üìú Move History</h3>
                                    <div className="space-y-2 max-h-40 overflow-y-auto">
                                        {moveHistory.map((moveData, index) => (
                                            <div key={index} className="text-sm p-2 bg-gray-50 rounded">
                                                <div className="flex justify-between items-center">
                                                    <span className="font-medium">Move {index + 1}</span>
                                                    <span className="text-xs text-gray-500">
                                                        {new Date(moveData.timestamp).toLocaleTimeString()}
                                                    </span>
                                                </div>
                                                <div className="text-xs text-gray-600 mt-1">
                                                    {formatMoveDescription(moveData.move)}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="mt-2 text-xs text-gray-500">
                                        Total moves: {moveHistory.length}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        // Render the app using React 18 createRoot
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html> 